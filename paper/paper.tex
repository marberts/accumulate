\documentclass[11pt, fleqn]{article}
\usepackage[english]{babel}
\usepackage{amsmath, amssymb}

\usepackage[ruled, linesnumbered]{algorithm2e}


\usepackage{natbib}
\setlength{\parskip}{\baselineskip}%
\setlength{\parindent}{0pt}%

\title{Spit-Apply-Combine with Collapsing Groups}
\author{Mark P.J. van der Loo}
\date{CONCEPT \today{}}

\begin{document}
\maketitle

\section{Introduction}
The operation of splitting a data set into non-overlapping groups, computing an
aggregate for each group, and combining the results into a new datasets is one
of the most common operations in data analyses. The idea behind this so-called
split-apply-combine approach is that the calculation for each groups only uses
data available within the group. However, in some cases the quality of data in
a group may be insufficient for producing a reliable group aggregate. Common
quality issues include insufficient records, or too many records with values
for certain variables missing. In such cases it is not uncommon to use data
from outside the target group  to estimate the group aggregate. One example is
Small Area Estimation, where the lack of observations in one group is
compensated by using data from similar but other groups. Another area where
such approaches occur is group-wise imputation. For example, one may wish to
impute a group estimate (say, mean, or median) for missing values. If there are
too little observations to provide an accurate estimate of the group mean, the
group may be expanded, trading bias for variance.

One approach that frequently occurs in practice is to use a so-called
collapsing scheme. In this approach one attempts to estimate the aggregate for
the most fine-grained grouping first.  If this is not possible, two or more
groups are combined to provide input for estimating a value for the
fine-grained group. The collapsing scheme defines which groups may be combined,
and it may consist of multiple levels of collapsing; in principle to the point
where the whole data set is used to estimate an aggregate value for a single
group.

Collapsing schemes can be the result of an optimisation, but they frequently
result from subject matter as well. For example, in the case of hierarchical
classifications, there is a natural ordering of groups that are similar from a
subject matter point of view (whether that means that they can be considered
representative for each other is another, statistical, question).  Examples
include the NACE classification of economic activities or the ISCO
classification of professions. Both have a tree-like structure that can be used
to combine groups with a common ancestor in the hierarchy.

In this paper we formalise the concept of `collapsing scheme', and give an
algorithm for split-apply-combine operations based on it. Next, we demonstrate
the R package \texttt{rcollapse} that implements this algorithm together with
some utility functions that make working with collapsing schemes easier.



\section{Formal descriptions and algorithms}
In this section we give a formal description of the algorithms. In order to be
unambiguous and to represent the algorithms compactly, we introduce some
notation. The notation also makes the pseudocode independent of the
implementation language used, or how the data is represented. 

We start by giving the algorithm for ordinary split-apply-combine, so it is
easy to see where the algorithm must be generalized to allow for a collapsing
scheme.


\subsection{Split-apply-combine}
In order to analyse a data set group by group we need to specify a data set, a
way to split it into groups, and a function that takes a subset of data and
returns an aggregate. Let us introduce some notation for that.

Let $U$ be a finite set, and let $\phi$ be a function that accepts a subset of
$U$ and returns a single value in some domain $X$. Here, $U$ is our data set
and $\phi$ an aggregating function. We split $U$ into groups using the
following notation. Let $A$ be finite set that has no more elements than $U$,
and let $f$ be a function that takes an element of $U$ and returns a value in
$A$. We can think of $A$ as a set of group labels, and $f$ as the function that
assigns a label to each element of $U$. This way, $f$ divides $U$ into
non-overlapping groups, since every element in $U$ can only get one label (that
is just how mathematical functions work). In formal terminology we say that
$f:U\to A$ is a \emph{partition} of $U$.

In this notation, any split-apply-combine operation can be computed with the following
algorithm.

\begin{algorithm}[H]
\caption{Split-Apply-Combine}
\label{alg:sac}
\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
\Input{A finite set $U$, an aggregator $\phi: 2^U\to X$, and a partition $f:U\to A$}
\Output{$R$: the value of $\phi$ for every part of $U$ as a set pairs $(a,x)\in
A\times X$ }

$R = \{\}$\;
\For{$a\in A$}{
  $d=f^{-1}(\{a\})$\tcp*{get subset of $U$}
  $R = R\cup \{(a,\phi(a))\}$\tcp*{aggregate and add to result}
}
\end{algorithm}
Here, the output is collected in a set $R$. We also introduced some new
notation: the notation $2^U$ stands for `the set of all subsets of $U$'. The
notation $f^{-1}$ stands for the formal \emph{inverse} of $f$. That is: you
give it a set of labels from $A$ and it returns all the elements of $U$ that
have any of those labels. This definition is slightly too general for the
current algorithm, but it will come in handy when we move to collapsing groups.

Let us see how the elements $U$, $f\to A$ and $\phi$ are implemented
in practice. Consider the signature of the R \texttt{aggregate} function for data
frames (we skip arguments that are not important for the discussion).
\begin{verbatim}
  aggregate(x, by, FUN)
\end{verbatim}
Here, \texttt{x} is a data frame where each column is a variable to be
aggregated.  The argument \texttt{by} represents the label(s) for each record
that are to be used for grouping. So the function $f\to A$ is implemented by
forcing the user to make sure that the position of each label in \texttt{by}
corresponds to the row number in the data frame \texttt{x}. The argument
\texttt{FUN} is the function that aggregates each subset of \texttt{x}.  Here is
an example of how a user might call this function from the R prompt.
%
\begin{verbatim}
> aggregate(iris["Sepal.Length"], by=iris["Species"], FUN=mean)
     Species Sepal.Length
1     setosa        5.006
2 versicolor        5.936
3  virginica        6.588
\end{verbatim}
%
Note that the correspondence in position of the \texttt{Species} label and the
record position is implemented by taking them from the same data frame. The output
also reveals in the first column the set $A$: each row corresponds to a unique
value in \texttt{Species} column.


\subsection{Split-apply-combine with collapsing groups}
The goal of the algorithm is to compute a value for each 
subset of a dataset, possibly using values from a larger
subset. The input of the algorithm consists again of a
finite set $U$, and aggregation function $\phi$ that takes
a subset of $U$ and returns a value in some domain $X$.
Compared to Algorithm~\ref{alg:sac} we need two extra
inputs. First, we need a user-defined function that checks whether
a given subset $d$ of $U$ is suitable for computing $\phi(d)$.
We will call this function $\beta: 2^U\to \mathbb{B}$, where
$\mathbb{B}=\{\texttt{True},\texttt{False}\}$. 
Typical tests are checking whether there are sufficient records
available, or whether certain variables have a low enough fraction
of missing values. Second, we need
a \emph{collapsing scheme}
\begin{equation}
U\xrightarrow{f_0}A_0\xrightarrow{f_1}A_1\xrightarrow{f_2}\cdots\xrightarrow{f_n}A_n.
\label{eq:collapsingsequence}
\end{equation}
A collapsing scheme is a sequence of partitions where each $f_i:A_{i-1}\to A_i$
partitions $A_{i-1}$ into $|A_i|$ groups. 

Collapsing schemes can be represented as tables. For example, the European NACE
classification is a hierarchical classification of economic activity. Each
group is encoded as a 4-digit code where the first digit indicates the highest
grouping level, and the last digit the most detailed level. This induces a
collapsing sequence by combining groups that have the same parent in the
hierarchy. Below is an example, based on a small piece of the NACE code list.
%
\begin{center}
\begin{tabular}{rrr}
\hline
 $A_0$& $A_1$ & $A_2$\\
\hline
0111&   011 & 01\\
0112&   011 & 01\\
0113&   011 & 01\\
0121&   012 & 01\\
0122&   012 & 01\\
0123&   012 & 01\\
0124&   012 & 01\\
\hline
\end{tabular}
\end{center}
Here, $A_0$ is the most detailed partition, splitting a dataset into seven
groups, relating to $\{0111,\ldots,0124\}$. In $A_1$ there are two groups.
The first, labeled $01.1$ is constructed by combining $0111, 0112$ and
$0113$ and the second, labeled $01.2$ is constructed by combining
$0121,\ldots 01.24$. Finally, in $A_2$ all groups are combined.

To compute an aggregate for records labeled with $0111$, the algorithm will
select those records and test whether the subset is suitable. If not, it will
move to $f_1(0111)=011$ and find all the groups in $A_0$ that map to 011 as
follows.
\begin{displaymath}
f_1^{-1}(\{011\}) = \{0111, 0112, 0113\}.
\end{displaymath}
It will then move on and find all records labeled with any of those three
group labels, and test again. If this new data set is suitable, the result is
computed, if not, another collapse takes place. The whole procedure is repeated 
for each element in $A_0$.




To generalize this algorithm to generic collapsing schemes, we introduce
the function $F_k:A_0\to A_k$, which accepts a label in $A_0$ and 
returns the corresponding label in $A_k$. This can formally be defined 
as consecutive application of $f_1, f_2\cdots, f_k$ to an element of 
$A_0$. In notation
\begin{equation*}
F_k \equiv f_k\circ f_{k-1}\circ\cdots\circ f_1.
\end{equation*}
Similarly we define $F^{-1}_k:2^{A_k}\to 2^{A_0}$ as the composition
\begin{equation*}
F_k^{-1} \equiv f_1^{-1}\circ f_2^{-1}\circ\cdots\circ f_k^{-1}.
\end{equation*}
This function asks for a set of labels in $A_k$ and returns all the labels in
$A_0$ that are mapped to that label via the collapsing sequence of
Equation~\eqref{eq:collapsingsequence}.  We are now ready to formally
write down our main Algorithm~\ref{alg:saccg}.

%
\begin{algorithm}[H]
\caption{Split-Apply-Combine with Collapsing Groups}
\label{alg:saccg}
\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
\Input{A finite set $U$, an aggregator $\phi: 2^U\to X$, a test function $\beta: 2^U\to \mathbb{B}$,
      and a collapsing sequence $U\xrightarrow{f_0}A_0\cdots \xrightarrow{f_n}  A_n$}

\Output{$R$: the value of $\phi$ for every part of $U$, for which a suitable
collapsing group can be found, as a set of triples $(a,k,x)\in A_0\times
A_k\times X $ with $0\leq k\leq n$.}

$R = \{\}$\;
\For{$a\in A_0$}{
  $i=0$\;
  $d = f_0^{-1}(\{a\})$\tcp*{get subset of $U$}
  \While{$i<n \land \lnot\beta(d)$}{
    $i = i+1$ \tcp*{Increase collapse level} 
    $d = (f_0^{-1}\circ F_i^{-1}\circ F_i)(a)$ \tcp*{Collapse and get subset}
  }
  \If{$\beta(d)$}{ \label{line:cond}
    $R = R\cup \{(a, i,\phi(d))\}$\;
  } 
}

\end{algorithm}
%
Since the used level of collapsing is determined dynamically by data
circumstances in $U$, the algorithm also reports the collapsing level used to
compute a value foe each member of $A_0$. For each member of $A_0$ there is a
triple $(a,i,\phi(d))$, where $a\in A_0$ is the label to which the value
$\phi(d)$ pertains, and $i$ is the number of collapses applied to reach a
suitable dataset. The condition in Line~\ref{line:cond} ensures that if
no suitable dataset is found after the whole collapsing sequence has been
executed, then no answer is returned.



\subsection{Caveat: unbalanced hierarchical classifications}
\begin{itemize}
\item tree with different levels of details
\end{itemize}

\section{The \texttt{rcollapse} package}

\begin{itemize}
\item{Specification of collapsing sequence with multiple collapsing variables (e.g. first size class, then NACE code)}
\end{itemize}

\bibliographystyle{plainnat}
\bibliography{vanderloo}
\end{document}


